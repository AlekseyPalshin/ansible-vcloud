#!/usr/bin/python


class User(object):
   
    def __new__(cls, *args, **kwargs):
        return load_platform_subclass(User, args, kwargs)

    def __init__(self, module):
    	self.module = module
    	self.name = module.params['user_name']
        self.password = module.params['user_password']
        self.info = module.params['user_info']
        self.groups = module.params['groups']
        self.state = module.params['state']
        self.ldap_base = module.params[ldap_base]
    
    def user_exists(self):
        return self.search_user_by_name() is not None

    def group_exists(self, group_name):
        return self.search_group_by_name(group_name) is not None

    def create_user(self):
        if (not self.group_exists(self.name)):
            rc, out, err = self.create_group(self.name)
            self.check_rc()

        cmd = [self.ldap_cmd('ldapadd'), self.user_ldif()]
        rc, out, err = self.module.execute_command(cmd)
        self.check_rc(rc, err)
        self.modify_group_members();
        return rc, out, err 

    def create_group(self, group_name):
    	cmd = [self.ldap_cmd('ldapadd'), self.group_ldif(group_name)]
        return self.module.execute_command(cmd)

    def modify_user(self):
    	cmd = [self.ldap_cmd('ldapmodify'), self.user_modify.ldif()]
    	rc, out, err = self.module.execute_command(cmd)
    	self.check_rc(rc, err)
        self.modify_group_members();
        return (rc, out, err)

    def modify_group_members(self):
    	for group in self.groups.split(','):
            if (not self.group_exists(group)):
                rc1, out1, err1 = self.create_group(group)
                self.check_rc(rc1, err1)
            self.modify_group(group)

    def modify_group(self, group_name):
    	group_info = self.search_group_by_name(group_name)
    	uids = group_info.memberUid
    	if (not isinstance(uids, list)):
    		uids = [uids]
    	for uid in uids:
    		if (uid equals self.name):
    			return
    	cmd = [self.ldap_cmd('ldapmodify'), self.group_modify_ldif(group_name)]
        return self.module.execute_command(cmd)

    def user_info(self):
    	if not self.user_exists():
            return False
        return self.search_user_by_uid()

    def remove_user(self):
        cmd = [self.ldap_cmd('ldapdelete'), self.ldap_user_dn()]
        return self.execute_command(cmd)

    def search_user_by_name(self):
    	cmd = [self.ldap_cmd('ldapsearch'), '-b', self.ldap_user_base(), self.ldap_user_uid()]
    	rc, out, err = self.execute_command(cmd)
    	self.check_rc(rc, err)
        entries = self.parse_ldap_output(out)
        if (len(entries) == 0):
        	return None
        return entries[0]

    def search_group_by_name(self, group_name):
    	cmd = [self.ldap_cmd('ldapsearch'), '-b', self.ldap_group_base(), self.ldap_cn(group_name)]
    	rc, out, err = self.module.execute_command(cmd)
    	self.check_rc(rc, err)
        entries = self.parse_ldap_output(out)
        if (len(entries) == 0):
        	return None
        return entries[0]

    def user_ldif(self):
    	return '\n'.join([
    		'>> EOF',
    	    ''.join(['dn: ', self.ldap_user_dn()]),
    	    ''.join(['uid: ', self.name]),
    	    ''.join(['cn: ', self.user_info]),
            'objectClass: top',
            'objectClass: account',
            'objectClass: posixAccount',
            ''.join(['userPassword: ', self.get_encripted_password()]),
            ''.join(['uidNumber: ', self.get_next_uid_number()]),
            ''.join(['gidNumber: ', self.get_gid_numbe(self.name))]),
            ''.join(['homeDirectory: /home/', self.name]),
            'loginShell: /bin/bash',
            ''.join(['gecos: ', self.name]),
            'EOF'])

    def user_modify_ldif(self):
    	return '\n'.join([
    		'>> EOF',
    	    ''.join(['dn: ', self.ldap_user_dn()]),
    	    'changetype: modify',
    	    'replace: userPassword',
            ''.join(['userPassword: ', self.get_encripted_password()]),
            'EOF'])

    def group_ldif(self, group_name):
    	return '\n'.join([
    		'>> EOF',
    	    ''.join(['dn: ', self.ldap_group_dn(group_name)]),
            'objectClass: posixGroup',
            'objectClass: top',
            ''.join(['cn: ', group_name]),
            ''.join(['gidNumber: ', get_next_gid_number()]),
            'EOF'])

    def group_modify_ldif(self, group_name):
    	return '\n'.join([
    		'>> EOF',
    	    ''.join(['dn: ', self.ldap_group_dn(group_name)]),
            'changetype: modify',
            'add: memberUid',
            ''.join(['memberUid: ', self.name]), 
            'EOF'])

    def get_encripted_password(self):
    	cmd = ['slappasswd', '-s', self.password]
    	rc, out, err = self.module.execute_command(cmd)
    	self.check_rc(rc, err)
    	return (out.splitlines())[0]

    def get_gid_number(self, group_name):
        group_info = self.search_group_by_name(group_name)
        if (group_info is None):
        	return None
        return group_info.gidNumber

    def	get_next_uid_number():
        max = 10000
        cmd = [self.ldap_cmd('ldapsearch'), '-b', self.ldap_user_base()]
        rc, out, err = self.module.execute_command(cmd)
        self.check(rc, err)
        for entry in self.parse_ldap_output(out):
        	uid_number = int(entry.uidNumber);
        	if (max < uid_number):
        		max = uid_number

    	return max + 1;
    
    def get_next_gid_number():
        max = 10000
        cmd = [self.ldap_cmd('ldapsearch'), '-b', self.ldap_group_base()]
        rc, out, err = self.module.execute_command(cmd)
        self.check(rc, err)
        for entry in self.parse_ldap_output(out):
        	uid_number = int(entry.gidNumber);
        	if (max < uid_number):
        		max = uid_number
    	return max + 1;

    def ldap_cmd(self, cmd):
        return ' '.join([cmd, '-Y EXTERNAL -H ldapi:///'])
    
    def ldap_user_dn(self):
    	return ','.join(self.ldap_uid(), self.ldap_user_base()])
    
    def ldap_group_dn(self, group_name):
    	return ','.join([self.ldap_cn(group_name), self.ldap_group_base()])

    def ldap_user_base(self):
        return ','.join(['ou=People', self.ldap_base])

    def ldap_group_base(self):
        return ','.join(['ou=Group', self.ldap_base])

    def ldap_uid(self):
        return ''.join(['uid=', self.name])

    def ldap_cn(self, cn):
        return ''.join(['cn=', cn])

    def parse_ldap_output(self, out):
        entries=[]
        current_entry=None
        for line in out.splitlines():
            if line.startswith('#') or line.startswith('\n'):
                continue
            
            if line.startswith('dn:'):
                current_entry={}
                entries.append(current_entry)
            
            arr = line.split(':', 1)
            if (current_entry is not None and len(arr) > 0):
            	if (not hasattr(current_entry, arr[0])):
            	    current_entry[arr[0]] = arr[1]
            	elif (not isinstance(current_entry[arr[0]], list)):
            	    current_entry[arr[0]] = [current_entry[arr[0]], arr[1]]
            	else:
            	    current_entry[arr[0]].append(arr[1])
        
        return entries

    def check_rc(self, rc, err):
    	if rc is not None and rc != 0:
            self.module.fail_json(name=self.name, msg=err, rc=rc)

    def execute_command(self, cmd, use_unsafe_shell=False, data=None):
        if self.syslogging:
            syslog.openlog('ansible-%s' % os.path.basename(__file__))
            syslog.syslog(syslog.LOG_NOTICE, 'Command %s' % '|'.join(cmd))

        return self.module.run_command(cmd, use_unsafe_shell=use_unsafe_shell, data=data)


# ===========================================    

def main():
    module = AnsibleModule(
        argument_spec=dict(
            user_name=dict(required=True, default=None, type='str'),
            user_password=dict(required=False, default=None, type='str'),
            user_info=dict(required=False, default=None, type='str'),
            groups=dict(required=False, default=None, type='str'),
            state = dict(default='present', choices=['present', 'absent']),
            ldap_base = dict(required=True, default=None, type='str')
        )
    )

    user = User(module)
    
    result = {}
    result['name'] = user.name
    result['state'] = user.state
    
    rc = None
    out = ''
    err = ''

    if user.state == 'absent':
        if user.user_exists():
            if module.check_mode:
                module.exit_json(changed=True)
            (rc, out, err) = user.remove_user()
            if rc != 0:
                module.fail_json(name=user.name, msg=err, rc=rc)

    elif user.state == 'present':
        if not user.user_exists():
            if module.check_mode:
                module.exit_json(changed=True)
            (rc, out, err) = user.create_user()
        else:
            # modify user (note: this function is check mode aware)
            (rc, out, err) = user.modify_user()

        if rc is not None and rc != 0:
            module.fail_json(name=user.name, msg=err, rc=rc)
        if user.password is not None:
            result['password'] = 'NOT_LOGGING_PASSWORD'

    if rc is None:
        result['changed'] = False
    else:
        result['changed'] = True
    if out:
        result['stdout'] = out
    if err:
        result['stderr'] = err

    if user.user_exists():
        info = user.user_info()
        if info == False:
            result['msg'] = "failed to look up user name: %s" % user.name
            result['failed'] = True
        result['uid'] = info[2]
        result['group'] = info[3]
        result['comment'] = info[4]
        result['home'] = info[5]
        result['shell'] = info[6]
        result['uid'] = info[2]
        if user.groups is not None:
            result['groups'] = user.groups

    module.exit_json(**result)

# ===========================================
    
# import module snippets
from ansible.module_utils.basic import *
main()